# brainFuck

写个brainFuck的代码，然后再pwn掉他。出这题的原因是题目代码很好写。实现一个brainFuck的编译器就可以了。然后一开始没怎么考虑清楚，把缓冲区放在了堆上，然后发现这个程序基本上无解Orz。临时修改题目，改到了栈上。这样就可以做了。

其实也不难，稍微了解一下brainFuck很容易就能写出各种功能的代码。leak libc然后构造rop跳转就可以。这里给一段可行的brainFuck代码

> `'[.>.>.>.>.>.>.>.>]>>>>>>>>>>>>>>>>,>,>,>,>,>,>,>,>]q'`

这段代码就可以打印堆结构，绕过canary，覆盖返回值。最后按照rop链的长度修改最后一段输入的长度就可以了